// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include "hal/hal.h"
#include EMBER_AF_API_EEPROM
#include EMBER_AF_API_STACK
#include EMBER_AF_API_NVM3
#include EMBER_AF_API_ZCL_CORE
#include EMBER_AF_API_ZCL_OTA_BOOTLOAD_CORE
#include EMBER_AF_API_ZCL_OTA_BOOTLOAD_CLIENT






/** @brief Called whenever the EEPROM changes state
 *
 * @param oldEepromState The old state of the EEPROM
 * @param newEepromState The new state of the EEPROM
 * 
 */
void emberAfPluginEepromStateChangeCallback(HalEepromState oldEepromState, HalEepromState newEepromState)
{
}



/**
 * @brief Called whenever the radio is powered on.
 */
void halRadioPowerUpHandler(void)
{
}


/**
 * @brief Called whenever the radio is powered off.
 */
void halRadioPowerDownHandler(void)
{
}


/**
 * @brief Called whenever the microcontroller enters/exits a idle/sleep mode
 *
 * @param enter        True if entering idle/sleep, False if exiting
 * @param sleepMode    Idle/sleep mode
 */
void halSleepCallback(boolean enter, SleepModes sleepMode)
{
}


/** @brief Wake Up
 *
 * This function is called by the Idle/Sleep plugin after sleeping.
 *
 * @param durationMs The duration in milliseconds that the device slept.
 */
void emberAfPluginIdleSleepWakeUpCallback(uint32_t durationMs)
{
}


/** @brief Active
 *
 * This function is called by the Idle/Sleep plugin after idling.
 *
 * @param durationMs The duration in milliseconds that the device idled.
 */
void emberAfPluginIdleSleepActiveCallback(uint32_t durationMs)
{
}



/** @brief Mark Application Buffers
 *
 * This function is called when the application must mark its buffers.  Buffers
 * that are not marked will be reclaimed by the stack.
 */
void emberAfMarkApplicationBuffersCallback(void)
{
}



/** @brief Main
 *
 * This function is called immediately after the application starts executing
 * and can be used to perform initialization that should occur before any other
 * components are initialized.
 */
void emberAfMainCallback(MAIN_FUNCTION_PARAMETERS)
{
}

// The NVM3 Callback function.
void halNvm3Callback(Ecode_t status)
{
  // NVM3 does error handling internally, but this callback is included
  // in case the application requires any custom error handling.
}



/** @brief This function can be used to hook an external memory allocator into
 * the stack. It will be called when we need to allocate large packets.
 *
 * If a value other than NULL is returned that pointer will be used to store
 * packet data. You must also fill in the objectRef parameter with whatever
 * reference you would like passed to the emberFreeMemoryForPacketHandler()
 * when we're done with this memory. If you set the objectRef to NULL then
 * the free handler will not be called.
 *
 * @param size       size of packet data
 * @param objectRef  Reference of the memory to be used in
 *                   emberFreeMemoryForPacketHandler
 *
 * @return pointer that stores the packet data
 */
void *emberAllocateMemoryForPacketHandler(uint32_t size, void **objectRef)
{
  return NULL;
}


/** @brief This handler is called when freeing memory allocated with
 * ::emberAllocateMemoryForPacketHandler
 *
 * @param objectRef Reference used in ::emberAllocateMemoryForPacketHandler
 */
void emberFreeMemoryForPacketHandler(void *objectRef)
{
}



/**
 * @brief Application callback for emberSendDiagnosticQuery() and emberSendDiagnosticGet().
 *
 * @param status   Status of the query result.
 *
 * @param remoteAddress   The remote address that sent the answer.
 *
 * @param payload   The returned payload.
 *
 * @param payloadLength The returned payload length.
 */
void emberDiagnosticAnswerHandler(EmberStatus status,
                                  const EmberIpv6Address *remoteAddress,
                                  const uint8_t *payload,
                                  uint16_t payloadLength)
{
#if defined(EMBER_AF_PLUGIN_NCP_LIBRARY) && defined(EMBER_AF_PLUGIN_THREAD_TEST_HARNESS_CLI)
  extern void emberDiagnosticAnswerHandlerTth(EmberStatus status,
                                              const EmberIpv6Address *remoteAddress,
                                              const uint8_t *payload,
                                              uint16_t payloadLength);
  emberDiagnosticAnswerHandlerTth(status, remoteAddress, payload, payloadLength);
#endif
}


/**
 * @brief  Application callback for the stack to obtain the battery level
 * to use in a response to a network diagnostic request.  From the Thread spec:
 * "The battery level is an 8-bit unsigned integer that indicates remaining 
 * battery energy in the Thread device as an integer percentage value 0-100 
 * (0x00-0x64)."  
 *
 * @param batteryLevel  The battery level value to return to the stack.
 *
 * This handler should return false if the battery level is not measured,
 * unknown, or the device does not operate on battery power.  If a valid
 * battery level is being supplied, it must return true.
 *
 * The application must define EMBER_APPLICATION_HAS_BATTERY_LEVEL_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 *
 * This is an SOC-only API.
 */
bool emberBatteryLevelHandler(uint8_t *batteryLevel)
{
  return false;
}


/** @brief  Application callback for emberSetVendorTlvs().
 *
 * @param status EMBER_SUCCESS if the supplied TLVs were valid and successfully
 * installed, EMBER_BAD_ARGUMENT otherwise. See ::emberSetVendorTlvs for validity
 * requirements.
 *
 * @param length The number of bytes in the supplied network data.
 */
void emberSetVendorTlvsReturn(EmberStatus status, uint16_t length)
{
}


/** @brief  The response to a management get request previous sent via
 * emberSendManagementGetRequest().
 */
void emberManagementGetResponseHandler(EmberCoapStatus status,
                                       EmberCoapCode code,
                                       EmberCoapReadOptions *options,
                                       uint8_t *payload,
                                       uint16_t payloadLength,
                                       EmberCoapResponseInfo *info)
{
}


/** @brief A callback that indicates whether the attach process was
 * successfully initiated via a prior call to ::emberAttachToNetwork().
 * The status argument is either EMBER_SUCCESS, or EMBER_INVALID_CALL
 * if attach was called when the network status was not
 * EMBER_JOINED_NETWORK_NO_PARENT, or while an attach was underway.
 */
void emberAttachToNetworkReturn(EmberStatus status)
{
}


/** @brief Return call for emberBecomeCommissioner().  The status is
 * EMBER_SUCCESS if a petition was sent or EMBER_ERR_FATAL if some
 * temporary resource shortage prevented doing so.
 */
void emberBecomeCommissionerReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberChangeNodeType():
 * either EMBER_SUCCESS, or EMBER_INVALID_CALL.
 */
void emberChangeNodeTypeReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberAllowNativeCommissioner():
 * either EMBER_SUCCESS or EMBER_INVALID_CALL.
 */
void emberAllowNativeCommissionerReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetCommissionerKey():
 * either EMBER_SUCCESS or EMBER_INVALID_CALL.
 */
void emberSetCommissionerKeyReturn(EmberStatus status)
{
}


/** @brief Handler to let application know that a PSKc TLV was successfully set.
 *
 * @param pskc                   PSKc: 16 bytes in length
 */
void emberSetPskcHandler(const uint8_t *pskc)
{
}


/** @brief Provides the result of a call to emberSetJoinKey():
 * either EMBER_SUCCESS or EMBER_BAD_ARGUMENT.
 */
void emberSetJoinKeyReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetParentPriority():
 * either EMBER_SUCCESS or EMBER_INVALID_CALL
 */
void emberSetParentPriorityReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberGetParentPriority():
 *
 * @param parentPriority      Parent Priority
 */
void emberGetParentPriorityReturn(const int8_t parentPriority)
{
}


/** @brief Reports on the current commissioner state.
 *
 * @param flags    A combination of zero or more of the following:
 * - EMBER_HAVE_COMMISSIONER           a commissioner is active in the network
 * - EMBER_AM_COMMISSIONER             this device is the active commissioner
 *                                     if emberStopCommissioning is called, then
 *                                     this flag is not returned as we are open
 *                                     to commissioner petitions
 * - EMBER_JOINING_ENABLED             joining is enabled
 * - EMBER_JOINING_WITH_EUI_STEERING   steering data restricts which devices can
 *                                     join.  if not set, no restriction, any
 *                                     device can join (significant only when
 *                                     EMBER_JOINING_ENABLED is set)
 *
 * @param commissionerName    The name of the active commissioner, or
 *                            NULL if there is none or the name is not
 *                            known.
 *
 * @param commissionerNameLength    The length of commissonerName.
 */
void emberCommissionerStatusHandler(uint16_t flags,
                                    const uint8_t *commissionerName,
                                    uint8_t commissionerNameLength)
{
}


/** @brief Provides the result of a call to ::emberConfigureGateway */
void emberConfigureGatewayReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to ::emberSetNdData */
void emberSetNdDataReturn(EmberStatus status, uint16_t length)
{
}


/** @brief Provides the result of a call to ::emberSetLocalNetworkData */
void emberSetLocalNetworkDataReturn(EmberStatus status, uint16_t length)
{
}


/** @brief Provides the result of a call to ::emberConfigureExternalRoute */
void emberConfigureExternalRouteReturn(EmberStatus status)
{
}


/** @brief A callback invoked to inform the application of the
 * occurrence of an event defined by EmberCounterType, for example,
 * transmissions and receptions at different layers of the stack.
 *
 * The application must define EMBER_APPLICATION_HAS_COUNTER_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 * This function may be called in ISR context, so processing should
 * be kept to a minimum.
 *
 * @param type       The type of the event.
 * @param increment  Specify the increase in the counter's tally.
 *
 */
void emberCounterHandler(EmberCounterType type, uint16_t increment)
{
}


/** @brief A callback invoked to query the application for the
 * countervalue of an event defined by EmberCounterType.
 *
 * The application must define EMBER_APPLICATION_HAS_COUNTER_VALUE_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 *
 * @param   type       The type of the event.
 * @returns The counter's tally.
 *
 */
uint16_t emberCounterValueHandler(EmberCounterType type)
{
  return 0;
}


/** @brief A callback invoked to the application to reset the
 * countervalue of an event defined by EmberCounterType.
 *
 * The application must define EMBER_APPLICATION_HAS_COUNTER_VALUE_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 *
 * @param   type       The type of the event.
 */
void emberResetCounterHandler(EmberCounterType type)
{
}


/** @brief NCP handler called to process a custom message from the Host.
 *
 * @param message message received
 * @param messageLength length of message
 */
void emberCustomHostToNcpMessageHandler(const uint8_t *message,
                                        uint16_t messageLength)
{
#if defined(EMBER_AF_PLUGIN_NCP_LIBRARY) && defined(EMBER_AF_PLUGIN_THREAD_TEST_HARNESS_CLI)
  extern void emberCustomHostToNcpMessageHandlerTth(const uint8_t *message,
                                                    uint16_t messageLength);
  emberCustomHostToNcpMessageHandlerTth(message, messageLength);
#endif
}


/** @brief Host handler called to process a custom message from the NCP.
 *
 * @param message message received
 * @param messageLength length of message
 */
void emberCustomNcpToHostMessageHandler(const uint8_t *message,
                                        uint16_t messageLength)
{
}


/** @brief This method is called any time an event is scheduled from within an
 * ISR context. It can be used to determine when to stop a long running sleep
 * to see what application or stack events now need to be processed.
 * @param event The event that was scheduled by the ISR.
 */
void emberEventDelayUpdatedFromIsrHandler(Event *event)
{
}


/** @brief
 * This is called when the stack knows about a border router that has
 * an external route to a prefix.
 *
 * @param prefix                  external route prefix
 * @param prefixLengthInBits      length in bits of the prefix
 * @param available               whether this external route is available.
 */
void emberExternalRouteChangeHandler(const uint8_t *prefix,
                                     uint8_t prefixLengthInBits,
                                     bool available)
{
}


/** @brief
 * Provides the result of a call to ::emberForceTxAfterFailedCca.
 *
 * @param status EMBER_BAD_ARGUMENT if csmaAttempts
 *               is out of range, EMBER_SUCCESS otherwise.
 */
void emberForceTxAfterFailedCcaReturn(EmberStatus status)
{
}


/** @brief A callback that indicates whether a prior call to
 * ::emberFormNetwork() successfully initiated the form process.
 * The status argument is either EMBER_SUCCSS, or EMBER_INVALID_CALL
 * if resume was called when the network status was not EMBER_NO_NETWORK,
 * or a scan was underway.
 */
void emberFormNetworkReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberGetAntennaMode.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 * @param mode the current antenna mode
 *   0-don't alter antenna selection,
 *   1-antenna 1,
 *   2-antenna 2,
 *   3-TX antenna diversity
 */
void emberGetAntennaModeReturn(EmberStatus status,
                               uint8_t mode)
{
}


/** @brief
 * Provides the result of a call to ::emberGetAntennaRxMode.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 * @param mode the current RX antenna mode
 *   0-don't alter antenna selection,
 *   1-antenna 1,
 *   2-antenna 2,
 *   3-RX antenna diversity
 */
void emberGetAntennaRxModeReturn(EmberStatus status,
                                 uint8_t mode)
{
}


/** @brief Provides the result of a call to emberGetCcaThreshold(). */
void emberGetCcaThresholdReturn(int8_t threshold)
{
}


/** @brief
 * Gets the token information for tokenId = EMBER_CHANNEL_CAL_DATA_TOKEN
 *
 * @param lna          [msb: cal needed? | bit 0-5: lna tune value]
 * @param tempAtLna    [the temp (degC) when the LNA was calibrated]
 * #param modDac       [msb: cal needed? | bit 0-5: modulation DAC tune value]
 * @param tempAtModDac [the temp (degC) when the mod DAC was calibrated]
 */
void emberGetChannelCalDataTokenReturn(uint8_t lna,
                                       int8_t tempAtLna,
                                       uint8_t modDac,
                                       int8_t tempAtModDac)
{
}


/** @brief This callback returns the results of a call to emberGetChildEntry().
 * A status of EMBER_GET_CHILD_ENTRY_SUCCESS indicates a valid entry is being
 * returned in the EmberChildEntry argument, located at the supplied index in
 * the child table of size childTableSize. Note that the index returned is
 * the smallest index not less than the index that was supplied to
 * emberGetChildEntry(), which contains a valid child entry.
 *
 * If the child is not a Full Thread Device (as indicated in the EmberChildEntry
 * flags field), the parent stores the child's ipv6 addresses, which are then
 * returned by this callback as well.
 *
 * A status of EMBER_GET_CHILD_ENTRY_FAILURE indicates that no valid child entry
 * was found at or above the requested index.
 */
void emberGetChildEntryReturn(uint8_t status,
                              uint8_t index,
                              uint8_t childTableSize,
                              const EmberChildEntry *entry,
                              const EmberIpv6Address *addresses,
                              uint8_t addressCount)
{
}


/** @brief Provides the result of a call to emberGetCounter(). */
void emberGetCounterReturn(EmberCounterType type, uint16_t value)
{
}


/** @brief
 * Provides the result of a call to ::emberGetCtune.
 *
 * @param tune   The current CTUNE value.
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberGetCtuneReturn(uint16_t tune,
                         EmberStatus status)
{
}


/** @brief Provides the result of a call to ::emberGetGlobalPrefix
 *
 * @param flags               Please ignore this param, it is currently unused.
 *                            (returns 0)
 * @param isStable            Stable or temporary prefix
 * @param prefix              Border router prefix
 * @param prefixLengthInBits  Prefix length in bits
 * @param domainId            Provisioning domain ID
 * @param preferredLifetime   Preferred lifetime (in seconds)
 * @param validLifetime       Valid lifetime (in seconds)
 */
void emberGetGlobalPrefixReturn(uint8_t flags,
                                bool isStable,
                                const uint8_t *prefix,
                                uint8_t prefixLengthInBits,
                                uint8_t domainId,
                                uint32_t preferredLifetime,
                                uint32_t validLifetime)
{
}


/** @brief
 * This function is called when the link metrics initiator gets a link management response message
 *
 * @param status             link metrics request status
 * @param remoteAddress      IPv6 address of the subject
 */
void emberLinkMetricsMgmtHandler(EmberLinkMetricsStatus status,
                                 const uint8_t *remoteAddress)
{
}


/** @brief
 * This function is called when the link metrics initiator gets an MLE Data Response message
 * in response to a link metrics query.
 *
 * @param status             link metrics status
 * @param remoteAddress      IPv6 address of the subject
 * @param reportTlvValue     Link Metrics Report TLV Value field (Applicable only when status is Success(0), NULL otherwise)
 * @param reportTlvLength    Link Metrics Report TLV Length field (Applicable only when status is Success(0), 0 otherwise)
 */
void emberLinkMetricsResponseHandler(EmberLinkMetricsStatus status,
                                     const uint8_t *remoteAddress,
                                     const uint8_t *reportTlvValue,
                                     uint8_t reportTlvLength)
{
}


/** @brief
 * Provides the result of a call to ::emberGetMfgToken.
 *
 * @param tokenId         Which manufacturing token read.
 * @param status          An EmberStatus value indicating success or the
 * @param tokenData       The manufacturing token data.
 * @param tokenDataLength The length of the <i>tokenData</i> parameter in
 *                        bytes.
 */
void emberGetMfgTokenReturn(EmberMfgTokenId tokenId,
                            EmberStatus status,
                            const uint8_t *tokenData,
                            uint8_t tokenDataLength)
{
}


/** @brief
 * Provides the result of a call to ::emberGetNetworkData.
 *
 * The status value is one of:
 *  - EMBER_SUCCESS
 *  - EMBER_NETWORK_DOWN
 *  - EMBER_BAD_ARGUMENT (the supplied buffer was too small)
 *
 * @param status
 * @param networkData             location of the Network Data
 * @param dataLength              length in bytes of the Network Data
 */
void emberGetNetworkDataReturn(EmberStatus status,
                               uint8_t *networkData,
                               uint16_t bufferLength)
{
}


/** @brief Provides the result of a call to emberGetNetworkDataTlv().
 *
 * @param type the type of TLV returned. This is the same value as
 * the value specified in the emberGetNetworkDataTlv() call.
 * @param index the instance number of the TLV. This is the same value as
 * the value specified in the emberGetNetworkDataTlv() call.
 * @param versionNumber the network data version
 * @param tlv the TLV corresponding to type or NULL.
 * @param tlvLength length of tlv
 */
void emberGetNetworkDataTlvReturn(uint8_t typeByte,
                                  uint8_t index,
                                  uint8_t versionNumber,
                                  const uint8_t *tlv,
                                  uint8_t tlvLength)
{
}


/** @brief
 * Provides the result of a call to ::emberGetPtaDirectionalPriorityPulseWidth.
 *
 * @param pulseWidthUs Directional priority pulse width in microseconds
 */
void emberGetPtaDirectionalPriorityPulseWidthReturn(uint8_t pulseWidthUs)
{
}


/** @brief
 * Provides the result of a call to ::emberGetPtaEnable.
 *
 * @param enabled When true, indicates packet traffic arbitration
 * is enabed. When false, indicates packet traffic arbitration is
 * disabled.
 */
void emberGetPtaEnableReturn(bool enabled)
{
}


/** @brief
 * Provides the result of a call to ::emberGetPtaOptions.
 *
 * @param indicates packet traffic arbitration options
 * bit field.
 * Field                              Bit Position      Size(bits)
 * RX retry timeout ms                0                 8
 * Enable ack radio holdoff           8                 1
 * Abort mid TX if grant is lost      9                 1
 * TX request is high priority        10                1
 * RX request is high prioirity       11                1
 * RX retry request is high priority  12                1
 * RX retry request is enabled        13                1
 * Radio holdoff is enabled           14                1
 * Toggle request on mac retransmit   15                1
 * Force holdoff by disabling request 16                1
 * Hold off transmit in the mac layer 17                1
 * Delay asserting request until      18                1
 *   address filtering passes
 * Assert request with high priority  19                1
 *   after address filtering passes
 * CCA failure counter threshold      20                3
 * MAC retry counter threshold        23                2
 * MAC failure counter threshold      25                2
 * Reserved                           27                4
 * Hold request across CCA failures   31                1
 */
void emberGetPtaOptionsReturn(uint32_t options)
{
}


/** @brief
 * Provides the result of a call to ::emberGetPtaPhySelectTimeout.
 *
 * @param timeoutMs Packet traffic arbitration
 * PHY select timeout in milliseconds.
 */
void emberGetPtaPhySelectTimeoutReturn(uint8_t timeoutMs)
{
}


/** @brief
 * This function provides the result of a call to ::emberGetPtaPwmOptions.
 *
 * @param request  PTA PWM bit field
 * Field                              Bit Position      Size(bits)
 * Request enabled                    0                 1
 * Priority enabled                   1                 1
 * @param dutyCycle PTA PWM duty cycle percentage(0-100)
 * @param periodHalfMs PTA PWM request period in half milliseconds
 */
void emberGetPtaPwmOptionsReturn(uint8_t request,
                                 uint8_t dutyCycle,
                                 uint8_t periodHalfMs)
{
}


/** @brief Provides the result of a call to emberGetRadioPower() on the host. */
void emberGetRadioPowerReturn(int8_t power)
{
}


/** @brief Provides the result of a call to emberGetRipEntry(). */
void emberGetRipEntryReturn(uint8_t index, const EmberRipEntry *entry)
{
}


/** @brief Provides the result of a call to ::emberGetRoutingLocator
 *
 * @param rloc The Routing Locator as a full IPv6 address.
 */
void emberGetRoutingLocatorReturn(const EmberIpv6Address *rloc)
{
}


/** @brief
 * Provides the result of a call to ::emberGetStandaloneBootloaderInfo.
 *
 * @param version    BOOTLOADER_INVALID_VERSION if the standalone
 *                   bootloader is not present, or the version of
 *                   the installed standalone bootloader.
 * @param platformId The value of PLAT on the node.
 * @param microId    The value of MICRO on the node.
 * @param phyId      The value of PHY on the node.
 */
void emberGetStandaloneBootloaderInfoReturn(uint16_t version,
                                            uint8_t platformId,
                                            uint8_t microId,
                                            uint8_t phyId)
{
}


/** @brief Provides the result of a call to emberGetTxPowerMode() on the host.
 * @return the current tx power mode.
 */
void emberGetTxPowerModeReturn(uint16_t txPowerMode)
{
}


/** @brief In a host/NCP setup, notifies the host to set the new mesh local address.
 *
 * @param address IP address, 16 bytes
 */
void emberSetAddressHandler(const uint8_t *address)
{
}


/**
 * @brief In a host/NCP setup, notifies the host to changes in the network parameters.
 *
 * @param parameters Current network parameters
 * @param localEui64 The EUI64 of the Ember chip
 * @param macExtendedId The extended MAC ID of the Ember chip
 * @param networkStatus The current status of the network
 */
void emberHostStateHandler(const EmberNetworkParameters *parameters,
                           const EmberEui64 *localEui64,
                           const EmberEui64 *macExtendedId,
                           EmberNetworkStatus networkStatus)
{
}


/** @brief Provides the result of a call to emberInitiateLinkMetricsProbing():
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberInitiateLinkMetricsProbingReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberLaunchStandaloneBootloader.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberLaunchStandaloneBootloaderReturn(EmberStatus status)
{
}


/** @brief A callback invoked when the leader data changes.
 *
 *  The format of the leader data is as follows (Thread spec section 4.5.12):
 *  -------------------------------------------------------------------------------
 *  | octets: |      4       |  1     |     1     |        1          |   1       |
 *  -------------------------------------------------------------------------------
 *  |         | Partition ID | Weight | Data Ver. |  Stable Data Ver. | Router ID |
 *  -------------------------------------------------------------------------------
 *
 * @param leaderData the leader data
 */
void emberLeaderDataHandler(const uint8_t *leaderData)
{
}


/** @brief Application handler to define "passthrough" packets.
 *
 * @note This API is for SoCs only.
 * @note The application must define
 *       EMBER_APPLICATION_HAS_MAC_PASSTHROUGH_FILTER_HANDLER
 *
 * @param macHeader A pointer to the initial portion of the incoming MAC
 *                  header, in the standard 802.15.4 format.  The first
 *                  two bytes comprise the frame control, which dictates
 *                  source / destination PAN and addressing formats.
 *                  (See the MAC sublayer definition in the standards
 *                   definition 802.15.4e/2012)
 *
 *                  The relevant bytes of the header are:
 *  ----------------------------------------------------------------------
 *  | octets: |  2  |  1  |  0/2    |   0/2/8   |   0/2   |   0/2/8  | 
 *  ----------------------------------------------------------------------
 *  |         | ctl | seq | dst.pan |  dst.addr | src.pan | src.addr | ...
 *  ----------------------------------------------------------------------
 *                  Note that subsequent MAC fields, and the MAC payload,
 *                  may not yet be present at this point.
 *
 * @return true if the message is an application MAC passthrough message.
 */
bool emberMacPassthroughFilterHandler(uint8_t *macHeader)
{
  return false;
}


/** @brief Application handler to intercept "passthrough" packets and
 * handle them at the application.
 *
 * @note This API is for SoCs only.
 * @note The application must define
 *       EMBER_APPLICATION_HAS_MAC_PASSTHROUGH_MESSAGE_HANDLER
 *
 * @param header The message buffer pointing to the full 802.15.4 frame
 *               to be handled by the application.
 */
void emberMacPassthroughMessageHandler(PacketHeader header)
{
}


/** @brief Application handler to filter 802.15.4 packets to be observed
 * for signal strength.
 *
 * @note This API is for SoCs only.
 * @note The application must define
 *       EMBER_APPLICATION_HAS_RSSI_FILTER_HANDLER
 *
 * @param macHeader A pointer to the initial portion of the incoming MAC
 *                  header, in the standard 802.15.4 format.  The first
 *                  two bytes comprise the frame control, which dictates
 *                  source / destination PAN and addressing formats.
 *                  (See the MAC sublayer definition in the standards
 *                   definition 802.15.4e/2012)
 *
 *                  The relevant bytes of the header are:
 *  ----------------------------------------------------------------------
 *  | octets: |  2  |  1  |  0/2    |   0/2/8   |   0/2   |   0/2/8  | 
 *  ----------------------------------------------------------------------
 *  |         | ctl | seq | dst.pan |  dst.addr | src.pan | src.addr | ...
 *  ----------------------------------------------------------------------
 *                  Note that subsequent MAC fields, and the MAC payload,
 *                  may not yet be present at this point.
 *
 * @return true if the application wants to peek at the RSSI for this message.
 */
bool emberMacRssiFilterHandler(uint8_t *macHeader)
{
  return false;
}


/** @brief Gets the received signal strength indication (RSSI) for the
 * last 802.15.4 packet received by the stack.
 *
 * @note This is called on the application for all packets that match
 * the rule defined in ::emberMacRssiFilterHandler()
 *
 * The quantity referenced by currentRssi will contain the energy level
 * (in units of dBm) observed during the last 802.15.4 packet received
 * in that handler.
 *
 * @note This API is for SoCs only.
 * @note The application must define
 *       EMBER_APPLICATION_HAS_RSSI_FILTER_HANDLER
 *
 * @note This functionality is not available for packets such as 802.15.4
 * data requests or acknowledgements.  Data requests must be handled quickly
 * due to strict 15.4 timing requirements, and so the RSSI information is not
 * recorded.  Similarly, 802.15.4 ACKs are handled by the hardware and the
 * information does not make it up to the stack.
 *
 * @param currentRssi  The RSSI for the last incoming message processed.
 */
void emberMacRssiHandler(int8_t currentRssi)
{
}


/** @brief
 * This is called when the stack receives new Thread Network Data.
 *
 * @param networkData             the Network Data
 * @param length                  length in bytes of the Network Data
 */
void emberNetworkDataChangeHandler(const uint8_t *networkData, uint16_t length)
{
}


/** @brief  If implementing event-driven sleep on an NCP host, this method will
 * return the bitmask indicating the stack's current tasks. (see enum above)
 *
 *  The mask ::EMBER_HIGH_PRIORITY_TASKS defines which tasks are high
 *  priority.  Devices should not sleep if any high priority tasks are active.
 *  Active tasks that are not high priority are waiting for
 *  messages to arrive from other devices.  If there are active tasks,
 *  but no high priority ones, the device may sleep but should periodically
 *  wake up and call ::emberPollForData() in order to receive messages.  Parents
 *  will hold messages for ::EMBER_INDIRECT_TRANSMISSION_TIMEOUT (in quarter
 *  seconds) before discarding them.
 *
 * @return A bitmask of the stack's active tasks.
 */
void emberOkToNapReturn(uint8_t stateMask)
{
}


/** @brief Provides the result of a call to emberPollForData().
 * @param An EmberStatus value:
 * - ::EMBER_SUCCESS      - The poll message has been submitted for transmission
 * - ::EMBER_INVALID_CALL - The node is not a sleepy end device.
 * - ::EMBER_NOT_JOINED   - The node is not part of a network.
 */
void emberPollForDataReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberRadioGetRandomNumbers.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure. When EMBER_SUCCESS is returned
 *               ::rn and ::count will contain valid data.  ::rn
                 and ::count are undefined when EMBER_SUCCESS is not
 *               returned.
 * @param rn the uint16_t random values
 * @param count - the count of uint16_t values located at ::rn
 */
void emberRadioGetRandomNumbersReturn(EmberStatus status,
                                      const uint16_t *rn,
                                      uint8_t count)
{
}


/** @brief
 *
 * This function provides the result of a call to ::emberRequestDomainUniqueAddress.
 *
 * This call only indicates the status of the request (EMBER_ERR_FATAL if no
 * PBBR is found, and EMBER_SUCCESS otherwise).  The assigned IPv6 address is
 * returned via ::emberAddressConfigurationChangeHandler
 *
 * @param status                  Status of DUA Request
 * @param prefix                  Prefix requested in ::emberRequestDomainUniqueAddress
 * @param prefixLengthInBits      Prefix length in bits requested in
 *                                ::emberRequestDomainUniqueAddress
 */
void emberRequestDomainUniqueAddressReturn(EmberStatus status,
                                           const uint8_t *prefix,
                                           uint8_t prefixLengthInBits)
{
}


/** @brief
 *
 * This function provides the result of a call to ::emberRequestMulticastListener.
 * This call only indicates the status of the request.
 *
 * @param status                  Status of MLR Request
 * @param multicastGroupAddress   IPv6 address representing the multicast group
 */
void emberRequestMulticastListenerReturn(EmberStatus status,
                                         const EmberIpv6Address *address)
{
}


/** @brief
 *
 * This function provides the result of a call to ::emberAddMeshDuaEntry.
 *
 * @param status                  EMBER_SUCCESS or EMBER_TABLE_FULL
 */
void emberAddMeshDuaEntryReturn(EmberStatus status, const EmberIpv6Address *dua)
{
}


/** @brief
 *
 * This function provides the result of a call to ::emberRemoveMeshDuaEntry.
 *
 * @param status                  EMBER_SUCCESS or EMBER_BAD_ARGUMENT
 */
void emberRemoveMeshDuaEntryReturn(EmberStatus status, const EmberIpv6Address *dua)
{
}


/** @brief
 * Provides the result of a call to emberResignGlobalAddress().
 */
void emberResignGlobalAddressReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSendLinkMetricsQuery():
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSendLinkMetricsQueryReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSendLinkProbeMessages():
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSendLinkProbeMessagesReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSendSteeringData(). */
void emberSendSteeringDataReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetAntennaMode.
 *
 * @param EMBER_SUCCESS if antenna mode is configured as desired
 * or EMBER_BAD_ARGUMENT if antenna mode is not supported.
 */
void emberSetAntennaModeReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetAntennaRxMode.
 *
 * @param EMBER_SUCCESS if RX antenna mode is configured as desired
 * or EMBER_BAD_ARGUMENT if RX antenna mode is not supported.
 */
void emberSetAntennaRxModeReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetCcaThreshold(). */
void emberSetCcaThresholdReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetCtune.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetCtuneReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetMfgToken.
 *
 * @param tokenId         Which manufacturing token set.
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetMfgTokenReturn(EmberMfgTokenId tokenId,
                            EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetPtaDirectionalPriorityPulseWidth.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetPtaDirectionalPriorityPulseWidthReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetPtaEnable.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetPtaEnableReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetPtaOptions.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetPtaOptionsReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetPtaPhySelectTimeout.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetPtaPhySelectTimeoutReturn(EmberStatus status)
{
}


/** @brief
 * This function provides the result of a call to ::emberSetPtaPwmOptions.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetPtaPwmOptionsReturn(EmberStatus status)
{
}


/** @brief
 * Provides the result of a call to ::emberSetRadioHoldOff.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure. EMBER_SUCCESS if Radio HoldOff
 *               was configured as desired or EMBER_BAD_ARGUMENT
 *               if requesting it be enabled but RHO has not been
 *               configured by the BOARD_HEADER.
 */
void emberSetRadioHoldOffReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetRadioPower() on the host. */
void emberSetRadioPowerReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetSecurityParameters(). */
void emberSetSecurityParametersReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetTxPowerMode() on the host. */
void emberSetTxPowerModeReturn(EmberStatus status)
{
}


/** @brief
 * This function provides the result of a call to ::emberConfigureDefaultDomainPrefix
 *
 * @param status               EMBER_SUCCESS or EMBER_BAD_ARGUMENT
 * @param prefix               Default domain prefix
 * @param prefixLengthInBits   Length in bits of the prefix
 */
void emberConfigureDefaultDomainPrefixReturn(EmberStatus status,
                                             const uint8_t *prefix,
                                             uint8_t prefixLengthInBits)
{
}


/** @brief
 * This function provides the result of a call to ::emberConfigureDefaultDomainPrefix
 *
 * @param status               EMBER_SUCCESS or EMBER_INVALID_CALL
 * @param primary              true indicates that we are active in a primary BBR role.
 */
void emberBecomeBackboneRouterReturn(EmberStatus status, bool primary)
{
}


/** @brief
 * This function provides the result of a call to ::emberSetBbrDataset
 *
 * @param status               EMBER_SUCCESS
 */
void emberSetBbrDatasetReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberStackPollForData(). */
void emberStackPollForDataReturn(EmberStatus status)
{
}


/** @brief Callback to tell the host to start security commissioning
 *
 * @param address parent IP address, 16 bytes
 */
void emberStartHostJoinClientHandler(const uint8_t *parentAddress)
{
}


/**
 * @brief In a host/NCP setup, provides the result of a call to emberState() on the host.
 *
 * @param parameters Current network parameters
 * @param localEui64 The EUI64 of the Ember chip
 * @param macExtendedId The extended MAC ID of the Ember chip
 * @param networkStatus The current status of the network
 */
void emberStateReturn(const EmberNetworkParameters *parameters,
                      const EmberEui64 *localEui64,
                      const EmberEui64 *macExtendedId,
                      EmberNetworkStatus networkStatus)
{
}


/** @brief
 * This can be stubbed out on the SoC and host app.  It is used by the
 * NCP to update security on the driver when it is instructed to switch
 * the network key by an over the air update.
 *
 */
void emberSwitchToNextNetworkKeyHandler(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSwitchToNextNetworkKey(). */
void emberSwitchToNextNetworkKeyReturn(EmberStatus status)
{
}


/** @brief Provides the result of a call to emberSetDtlsDeviceCertificate().
 *
 * @param result
 * - ::0      The certificate was set successfully.
 * - ::result error code
 *            - an EmberStatus value if using Silicon Labs TLS
 *            - an mbed TLS error code if using mbed TLS library
 *            (see mbedtls:include/mbedtls/ssl.h)
 */
void emberSetDtlsDeviceCertificateReturn(uint32_t result)
{
}


/** @brief Provides the result of a call to emberSetDtlsPresharedKey().
 *
 * @param result
 * - ::status An EmberStatus value
 */
void emberSetDtlsPresharedKeyReturn(EmberStatus status)
{
}


/** @brief
 * Callback informing the application running on the micro of interruptions 
 * to normal processing. If ::busy is true, the micro will be busy processing
 * and unavailable for an indefinite period of time. If ::busy is false, the
 * micro has resumed normal operation.  The main use case is jpake crypto
 * on EM3xx processors. This gives the application a chance to prepare for
 * the pause in regular processing.
 *
 * This callback is not available on a host processor.
 * Note that if ::busy is true, the micro may become busy as soon as this
 * handler exits. In a host/ncp setup, one solution for informing the
 * host is to implement this handler in your own xNCP image and use it to
 * toggle the serial CTS line.
 */
void emberMicroBusyHandler(bool busy)
{
}



/** @brief The radio calibration callback function.
 *
 * The Voltage Controlled Oscillator (VCO) can drift with
 * temperature changes.  During every call to ::emberTick(), the stack will
 * check to see if the VCO has drifted.  If the VCO has drifted, the stack
 * will call ::emberRadioNeedsCalibratingHandler() to inform the application
 * that it should perform calibration of the current channel as soon as
 * possible.  Calibration can take up to 150ms.  The default callback function
 * implementation provided here performs calibration immediately.  If the
 * application wishes, it can define its own callback by defining
 * ::EMBER_APPLICATION_HAS_CUSTOM_RADIO_CALIBRATION_CALLBACK in its
 * CONFIGURATION_HEADER.  It can then failsafe any critical processes or
 * peripherals before calling ::emberCalibrateCurrentChannel().  The
 * application must call ::emberCalibrateCurrentChannel() in
 * response to this callback to maintain expected radio performance.
 */
void emberRadioNeedsCalibratingHandler(void)
{
  // TODO: Failsafe any critical processes or peripherals.
  emberCalibrateCurrentChannel();
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberAssertInfo
 */
void emberAssertInfoReturn(const uint8_t *fileName, uint32_t lineNumber)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberConfigUart
 */
void emberConfigUartReturn(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberEcho
 */
void emberEchoReturn(const uint8_t *data, uint8_t length)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberGetMulticastEntry
 */
void emberGetMulticastEntryReturn(uint8_t lastSequence,
                                  uint8_t windowBitmask,
                                  uint8_t dwellQs,
                                  const uint8_t *seed)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberGetNetworkKeyInfo
 */
void emberGetNetworkKeyInfoReturn(EmberStatus status,
                                  uint32_t sequence,
                                  uint8_t state)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberGetNodeStatus
 */
void emberGetNodeStatusReturn(EmberStatus status,
                              const EmberNetworkDebugParameters *parameters)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberNcpUdpStormComplete
 */
void emberNcpUdpStormCompleteHandler(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberNcpUdpStorm
 */
void emberNcpUdpStormReturn(EmberStatus status)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberResetNcpAsh
 */
void emberResetNcpAshReturn(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberSendDone
 */
void emberSendDoneReturn(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberSetRandomizeMacExtendedId
 */
void emberSetRandomizeMacExtendedIdReturn(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberStartUartStorm
 */
void emberStartUartStormReturn(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberStopUartStorm
 */
void emberStopUartStormReturn(void)
{
}


/** @brief Callback for a debug command.  Provides the result of
 * ::emberUartSpeedTest
 */
void emberUartSpeedTestReturn(uint32_t totalBytesSent,
                              uint32_t payloadBytesSent,
                              uint32_t timeout)
{
}


/** @brief  Application callback for an incoming UDP multicast.
 *
 * @param destination     IPV6 destination address
 * @param source          IPV6 source address
 * @param localPort       UDP source port
 * @param remotePort      UDP destination port
 * @param payload         UDP transport payload
 * @param payloadLength   payload length
 */
void emberUdpMulticastHandler(const uint8_t *destination,
                              const uint8_t *source,
                              uint16_t localPort,
                              uint16_t remotePort,
                              const uint8_t *payload,
                              uint16_t payloadLength)
{
  emberUdpHandler(destination,
                  source,
                  localPort,
                  remotePort,
                  payload,
                  payloadLength);
}


/**************************************************************************//**
 * An attribute is about to change value.
 *
 * @param endpointId The endpoint to which the new attribute value applies
 * @param clusterSpec The cluster to which the new attribute value applies
 * @param attributeId The attribute ID
 * @param buffer The data representing the new attribute value
 * @param bufferLength The length of the new attribute value data
 * @return `true` if the attribute should take this new value, `false`
 *         otherwise.
 *
 * This callback gives the application an opportunity to prevent an attribute
 * from changing value by returning `false`.
 *
 * @sa emberZclPostAttributeChangeCallback
 *****************************************************************************/
bool emberZclPreAttributeChangeCallback(EmberZclEndpointId_t endpointId,
                                        const EmberZclClusterSpec_t *clusterSpec,
                                        EmberZclAttributeId_t attributeId,
                                        const void *buffer,
                                        size_t bufferLength)
{
  return true;
}


/**************************************************************************//**
 * An external attribute value needs to be read.
 *
 * @param endpointId The endpoint to which the attribute value applies
 * @param clusterSpec The cluster to which the attribute value applies
 * @param attributeId The attribute ID
 * @param buffer The data buffer into which the attribute value will be read
 * @param bufferLength The length of the data buffer
 * @return An ::EmberZclStatus_t value representing the success or failure of
 *         the read operation.
 *
 * This callback alerts the application that an externally stored attribute
 * needs to be read. The application is expected to read the attribute value
 * from its external storage, populate the buffer parameter with the attribute
 * value, and return an ::EmberZclStatus_t value representing the success or
 * failure of the read operation.
 *
 * @sa emberZclWriteExternalAttributeCallback
 *****************************************************************************/
EmberZclStatus_t emberZclReadExternalAttributeCallback(EmberZclEndpointId_t endpointId,
                                                       const EmberZclClusterSpec_t *clusterSpec,
                                                       EmberZclAttributeId_t attributeId,
                                                       void *buffer,
                                                       size_t bufferLength)
{
  return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
}


/**************************************************************************//**
 * An external attribute value needs to be written.
 *
 * @param endpointId The endpoint to which the attribute value applies
 * @param clusterSpec The cluster to which the attribute value applies
 * @param attributeId The attribute ID
 * @param buffer The data buffer holding the attribute value to be written
 * @param bufferLength The length of the data buffer
 * @return An ::EmberZclStatus_t value representing the success or failure of
 *         the write operation.
 *
 * This callback alerts the application that an externally stored attribute
 * needs to be written. The application is expected to write the attribute value
 * to its external storage and return an ::EmberZclStatus_t value representing
 * the success or failure of the write operation.
 *
 * @sa emberZclReadExternalAttributeCallback
 *****************************************************************************/
EmberZclStatus_t emberZclWriteExternalAttributeCallback(EmberZclEndpointId_t endpointId,
                                                        const EmberZclClusterSpec_t *clusterSpec,
                                                        EmberZclAttributeId_t attributeId,
                                                        const void *buffer,
                                                        size_t bufferLength)
{
  return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
}


/**************************************************************************//**
 * A notification has been received.
 *
 * @param context Information about the notification
 * @param clusterSpec The cluster to which the attribute applies
 * @param attributeId The attribute ID to which the notification applies
 * @param buffer The data buffer containing the reported attribute value
 * @param bufferLength The length of the data buffer
 *****************************************************************************/
void emberZclNotificationCallback(const EmberZclNotificationContext_t *context,
                                  const EmberZclClusterSpec_t *clusterSpec,
                                  EmberZclAttributeId_t attributeId,
                                  const void *buffer,
                                  size_t bufferLength)
{
}


/*
 * Callback for handling a ZCL message.
 *   cluster: Identify
 *   command: EZModeInvoke
 *      side: server
 */
void emberZclClusterIdentifyServerCommandEZModeInvokeRequestHandler(
  const EmberZclCommandContext_t *context,
  const EmberZclClusterIdentifyServerCommandEZModeInvokeRequest_t *request)
{
  emberZclSendDefaultResponse(context, EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND);
}


/*
 * Callback for handling a ZCL message.
 *   cluster: Identify
 *   command: UpdateCommissionState
 *      side: server
 */
void emberZclClusterIdentifyServerCommandUpdateCommissionStateRequestHandler(
  const EmberZclCommandContext_t *context,
  const EmberZclClusterIdentifyServerCommandUpdateCommissionStateRequest_t *request)
{
  emberZclSendDefaultResponse(context, EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND);
}


/*
 * Callback for handling a ZCL message.
 *   cluster: Identify
 *   command: TriggerEffect
 *      side: server
 */
void emberZclClusterIdentifyServerCommandTriggerEffectRequestHandler(
  const EmberZclCommandContext_t *context,
  const EmberZclClusterIdentifyServerCommandTriggerEffectRequest_t *request)
{
  emberZclSendDefaultResponse(context, EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND);
}


/*
 * Callback for handling a ZCL message.
 *   cluster: On/off
 *   command: OffWithEffect
 *      side: server
 */
void emberZclClusterOnOffServerCommandOffWithEffectRequestHandler(
  const EmberZclCommandContext_t *context,
  const EmberZclClusterOnOffServerCommandOffWithEffectRequest_t *request)
{
  emberZclSendDefaultResponse(context, EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND);
}


/*
 * Callback for handling a ZCL message.
 *   cluster: On/off
 *   command: OnWithRecallGlobalScene
 *      side: server
 */
void emberZclClusterOnOffServerCommandOnWithRecallGlobalSceneRequestHandler(
  const EmberZclCommandContext_t *context,
  const EmberZclClusterOnOffServerCommandOnWithRecallGlobalSceneRequest_t *request)
{
  emberZclSendDefaultResponse(context, EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND);
}


/*
 * Callback for handling a ZCL message.
 *   cluster: On/off
 *   command: OnWithTimedOff
 *      side: server
 */
void emberZclClusterOnOffServerCommandOnWithTimedOffRequestHandler(
  const EmberZclCommandContext_t *context,
  const EmberZclClusterOnOffServerCommandOnWithTimedOffRequest_t *request)
{
  emberZclSendDefaultResponse(context, EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND);
}


