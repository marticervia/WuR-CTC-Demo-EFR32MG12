// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This callback file is created for your convenience. You may add application
// code to this file. If you regenerate this file over a previous version, the
// previous version will be overwritten and any code you have added will be
// lost.
#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include "hal/hal.h"
#include EMBER_AF_API_EEPROM
#include EMBER_AF_API_STACK
#include EMBER_AF_API_NVM3
#include EMBER_AF_API_ZCL_CORE
#include EMBER_AF_API_ZCL_OTA_BOOTLOAD_CORE
#include EMBER_AF_API_ZCL_OTA_BOOTLOAD_CLIENT
#include "rtcdriver.h"

#include "ook-test.h"
#include "i2c_wur.h"

/** @brief Init
 *
 * This function is called after the stack initializes and can be used to
 * perform any additional initialization required at stack startup.  On SoCs,
 * this will generally be called only once: at system startup.  On hosts, this
 * will be called when the NCP initializes, and may be called multiple times
 * during the lifetime of the host application.
 */
void emberAfInitCallback(void)
{
	emberAfCorePrintln("----------- Starting OOK Task! -----------");
	int32_t res = startOOKRadio();
	emberAfCorePrintln("Launched OOK task with res %d.", res);

	emberAfCorePrintln("----------- Starting i2c WuR interface! -----------");
	wur_i2c_init();
	emberAfCorePrintln("----------- Started i2c WuR interface! -----------");

}

/** @brief Tick
 *
 * This function is called in each iteration of the main application loop and
 * can be used to perform periodic functions.  The frequency with which this
 * function is called depends on how quickly the main loop runs.  If the
 * application blocks at any time during the main loop, this function will not
 * be called until execution resumes.  On SoC platforms, sleeping and idling
 * will block.  On Unix hosts, process yielding (e.g., via select) will block.
 */
uint32_t ook_frame_timestamp = 0;
uint32_t i2c_frame_timestamp = 0;

void emberAfTickCallback(void)
{
	uint32_t current_timestamp = halCommonGetInt32uMillisecondTick();
	uint16_t wur_addr;
	//run each second
	if(100 <= elapsedTimeInt32u(ook_frame_timestamp, current_timestamp)){
		//emberAfCorePrintln("[%d]: Preparing OOK frame.", current_timestamp);
		int32_t res = sendOOKFrame();
		if(res == 0){
			//emberAfCorePrintln("[%d]: Launched OOK frame with res %d.", current_timestamp, res);
			ook_frame_timestamp = current_timestamp;
		}else{
			emberAfCorePrintln("[%d]: Failed to launch OOK frame with res %d.", current_timestamp, res);
			ook_frame_timestamp = current_timestamp;
		}
	}
	if(1000 <= elapsedTimeInt32u(i2c_frame_timestamp, current_timestamp)){
		int32_t res = wur_get_address(&wur_addr);
		if(res == 0){
			emberAfCorePrintln("[%d]: Got WuR Addr 0x%02x.", current_timestamp, res);
			i2c_frame_timestamp = current_timestamp;
		}else{
			emberAfCorePrintln("[%d]: Failed to get WuR address with res %d.", current_timestamp, res);
			i2c_frame_timestamp = current_timestamp;
		}
	}
}


/** @brief Ok To Idle
 *
 * This function is called by the Idle/Sleep plugin before idling.  It is called
 * with interrupts disabled.  The application should return true if the device
 * may idle or false otherwise.
 *
 * @param durationMs The maximum duration in milliseconds that the device will
 * idle.
 */
bool emberAfPluginIdleSleepOkToIdleCallback(uint32_t durationMs)
{
  return false;
}

bool emberAfPluginIdleSleepOkToSleepCallback(uint32_t durationMs)
{
  // Once we join to a network, we will automatically stay awake, because we
  // are a router.  Before we join, we would could sleep, but we prevent that
  // by returning false here.
  return false;
}



